### [831. KMP字符串 - AcWing题库](https://www.acwing.com/problem/content/833/)

#KMP

给定一个字符串 $S$，以及一个模式串 $P$，所有字符串中只包含大小写英文字母以及阿拉伯数字。

模式串 $P$ 在字符串 $S$ 中多次作为子串出现。

求出模式串 $P$ 在字符串 $S$ 中所有出现的位置的起始下标。

#### 输入格式

第一行输入整数 $N$，表示字符串 $P$ 的长度。

第二行输入字符串 $P$。

第三行输入整数 $M$，表示字符串 $S$ 的长度。

第四行输入字符串 $S$。

#### 输出格式

共一行，输出所有出现位置的起始下标（下标从 $0$ 开始计数），整数之间用空格隔开。

#### 数据范围

$1≤N≤10^5$
$1≤M≤10^6$

#### 输入样例：

```
3
aba
5
ababa
```

#### 输出样例：

```
0 2
```

### 模板

```cpp
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```

### 代码

```cpp
#include <iostream>

using namespace std;

const int N = 1e6 + 10, M = 1e5 + 10;

int n, m;
char s[N], p[M];
int ne[M];// 表示next数组,用来存储最长公共子串的长度
// next[i] = j表示以i为终点的后缀与以1为起点的前缀相等且最长
// p[1, j] = p[i - j + 1, i];

/*测试样例
9 a b a b a b c a b
  1 2 3 4 5 6 7 8 9
14 ababccbababcab
*/

int main(void){

    cin >> n >> p + 1 >> m >> s + 1;
    // 字符串从下标为1的位置开始读入ac

    // 求next过程
    for(int i = 2, j = 0; i <= n; i++){// ne[1]为0,不要计算,所以从2开始循环
        while(j && p[i] != p[j + 1]) 
            j = ne[j];
        if(p[i] == p[j + 1]) 
            j++;
        ne[i] = j;
    } 
    // 该循环的第一步是在判断next[2]的情况,也就是第一个字符与第二个字符是否一样
    // 在j没有移动的时候,每一次q[i]都会与第一个字符进行比较

    // kmp匹配过程
    for(int i = 1, j = 0; i <= m; i++){
        while(j && s[i] != p[j + 1]) 
            j = ne[j];// 匹配后退 
        // j没有退回起点平且当前的si不能与下一个j的位置进行匹配
        if(s[i] == p[j + 1]) 
            j++;// 已经匹配
        if(j == n){//匹配成功
            printf("%d ", i - n + 1);
            j = ne[j];
        }
    }

    return 0;
}
```




*2022-08-22 周一*