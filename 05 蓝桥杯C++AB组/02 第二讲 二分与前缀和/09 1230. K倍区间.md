### [1230. K倍区间 - AcWing题库](https://www.acwing.com/problem/content/1232/)

给定一个长度为 $N$ 的数列，$A_1, A_2, …, A_N$，如果其中一段连续的子序列 $A_i,A_{i+1},…A_j$ 之和是 $K$ 的倍数，我们就称这个区间 $[i, j]$是 $K$ 倍区间。

你能求出数列中总共有多少个 $K$ 倍区间吗？

#### 输入格式

第一行包含两个整数 $N$ 和 $K$。

以下 $N$ 行每行包含一个整数 $A_i$。

#### 输出格式

输出一个整数，代表 $K$ 倍区间的数目。

#### 数据范围

$1 ≤ N, K ≤ 100000$
$1 ≤ A_i ≤ 100000$

#### 输入样例：

```
5 2
1
2
3
4
5
```

#### 输出样例：

```
6
```

#### 代码

```cpp
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 100010;

int n, k;
LL s[N], cnt[N];

int main(void){

    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i ++){
        scanf("%lld", &s[i]);
        s[i] += s[i - 1];
    }

    LL res = 0;
    cnt[0] = 1;
    
    for (int i = 1; i <= n; i ++ ){
        res += cnt[s[i] % k];
        cnt[s[i] % k] ++ ;
    }
    //答案等于前缀中出现过的和s[i]余k相等的计数之和
    //完成答案的计算之后需要将计数数组更新，加上自己

    printf("%lld\n", res);

    return 0;
}
    //这里一定要cnt[0]=1的原因是，当以被枚举的边界为右端点，
    //左端点为1的区间就是k倍区间时，并没有被加上1，
    //cnt[0]=1可以弥补掉自身没有加的那个1（此时s[r]%k也为0），
    //因为可以看到这里算的都是长度小于r的区间是否为k倍区间，
    //没有算长度为边界r的区间是否为k倍区间。
    //例如如果数组中的第一个元素就是k的倍数，但res在遍历i=1时，并不会+1，
    //但此时加上cnt[0]=1，就相当于弥补了这个没有加上的1
```




*2022-12-29 周四*