## [95. 费解的开关 - AcWing题库](https://www.acwing.com/problem/content/97/)

#枚举 #位运算 #偏移量

你玩过“拉灯”游戏吗？

$25$ 盏灯排成一个 $5 × 5$ 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。

下面这种状态

```in
10111
01101
10111
10000
11011
```

在改变了最左上角的灯的状态后将变成：

```in
01111
11101
10111
10000
11011
```

再改变它正中间的灯后状态将变成：

```in
01111
11001
11001
10100
11011
```

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。

#### 输入格式

第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。

以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

#### 输出格式

一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 `−1` 。

#### 数据范围

$0 < n ≤ 500$

#### 输入样例：

```in
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

#### 输出样例：

```out
3
2
-1
```

#### 思想

按法与按的顺序无关，即顺序可以任意

每个格子最多按一次

当前行需要进行的操作，被上一行的暗灭状态所唯一确定

操作细节：

1. 如何枚举第一行的操作

   我们用 $1$ 表示操作，用 $0$ 表示不操作，这五个数字可以看成一个二进制数，我们可以用 $0\sim2^5-1$这些数，来表示操作

2. 偏移量操作

#### 代码

```cpp
#include <iostream>
#include <cstring>

using namespace std;

const int N = 6;
char g[N][N], backup[N][N];
int dx[5] = {-1, 0, 1, 0, 0}, dy[5] = {0, 1, 0, -1, 0};
//偏移量

void turn(int x, int y){
    for(int i = 0; i < 5; i++){
        int a = x + dx[i], b = y + dy[i];
        if(a < 0 || a > 4 || b < 0 || b > 4) continue;
        g[a][b] ^= 1;// 将字符类型的0与1互换的操作
    }
}
//该题拉灯顺序可以更改
int main(void){

    int n;
    cin >> n;

    while(n--){
        for(int i = 0; i < 5; i++) cin >> g[i];
        int res = 10;// 取到比6大的数值就行
        for(int op = 0; op < 32; op++){// 枚举第一行所有按的方法
            memcpy(backup, g, sizeof g);// 复制数组，在备份上进行操作
            int step = 0;
            for(int i = 0; i < 5; i++){
                if(op >> i & 1){
                    step++;
                    turn(0, i);
                }
            }
            for(int i = 0; i < 4; i++){// 枚举剩下四行的状态
                for(int j = 0; j < 5; j++){
                    if(g[i][j] == '0'){
                        step++;
                        turn(i + 1, j);
                    }
                }
            }
            bool dark = false;
            //检查最后一行的状态
            for(int i = 0; i < 5; i++){
                if(g[4][i] == '0'){
                    dark = true;
                    break;
                }
            }
            if(dark == false) res = min(res, step);
            memcpy(g, backup, sizeof backup);
        }
        if(res > 6) res = -1;
        printf("%d\n", res);
    }
    return 0;
}
// void *memcpy(void *str1, const void *str2, size_t n)
// 从存储区 str2 复制 n 个字节到存储区 str1。     
// str1 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
// str2 指向要复制的数据源，类型强制转换为 void* 指针。
// n 要被复制的字节数。      
```


*2022-06-28 周二*