### [题目详情 - 实例1.1 最大子列和问题 (pintia.cn)](https://pintia.cn/problem-sets/434/problems/5404)

#动态规划 #分治 #子列

给定K个整数组成的序列 ${ N_1, N_2, ..., N_K }$，“连续子列”被定义为 ${ N_i, N_{i+1}, ..., N_j }$，其中 $1≤i≤j≤K$。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列 ${ -2, 11, -4, 13, -5, -2 }$，其连续子列 ${ 11, -4, 13 }$有最大的和 $20$。现要求你编写程序，计算给定整数序列的最大子列和。

本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：

- 数据1：与样例等价，测试基本正确性；
- 数据2：$10^2$个随机整数；
- 数据3：$10^3$个随机整数；
- 数据4：$10^4$个随机整数；
- 数据5：$10^5$个随机整数；

### 输入格式:

输入第 $1$ 行给出正整数 $K (≤100000)$；第 $2$ 行给出 $K$ 个整数，其间以空格分隔。

### 输出格式:

在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出 $0$。

### 输入样例:

```in
6
-2 11 -4 13 -5 -2
```

### 输出样例:

```out
20
```

### 思路

动态规划

归并

### 代码

#### 动态规划

```cpp
#include <iostream>

using namespace std;

const int N = 10;

int n;
int q[N];

int Max(void){
    int tmp = 0, sum = 0;
    for(int i = 1; i <= n; i++){
        tmp += q[i];
        if(tmp > sum) sum = tmp;
        else if(tmp < 0) tmp = 0;
    }
    return sum;
}

int main(void){

    cin >> n;

    int time = 0;
    for(int i = 1; i <= n; i++) scanf("%d", &q[i]), time += q[i];

    if(time <= -n) puts("0");
    else printf("%d", Max());  

    return 0;
}
```

#### 分治

```cpp
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n;
int q[N];

int max3(int a, int b, int c){
    int tmp = a > b ? a : b;
    return tmp > c ? tmp : c;
}

int merge(int l, int r){
    if(l >= r){
        if(q[l] > 0) return q[l];
        else return 0;
    }
    int mid = l + r >> 1;

    int max_left_sum = merge(l, mid);
    int max_right_sum = merge(mid + 1, r);

    int left_sum = 0, left_tmp = 0;
    for(int i = mid; i >= l; i--){// 判断左侧最大子序列
        left_tmp += q[i];
        left_sum = max(left_sum, left_tmp);
    }

    int right_sum = 0, right_tmp = 0;
    for(int i = mid + 1; i <= r; i++){// 判断右侧最大子序列
        right_tmp += q[i];
        right_sum = max(right_sum, right_tmp);
    }

    // 因为需要判断处于中间的最大子序列，
    // 故左侧从分界点向左侧循环， 右侧从分界点向右侧循环

    return max3(max_left_sum, max_right_sum, left_sum + right_sum);
}

int main(void){

    cin >> n;

    int tmp = 0;
    for(int i = 0; i < n; i++){
        scanf("%d", &q[i]);
        if(q[i] < 0) tmp++;
    }

    if(tmp == n) puts("0");
    else printf("%d\n", merge(0, n - 1));

    return 0;
}
```


*2022-06-26 周日*