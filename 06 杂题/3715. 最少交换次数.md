#### [3715. 最少交换次数 - AcWing题库](https://www.acwing.com/problem/content/3718/)

#逆序 #归并 #树状数组

给定一个 $1∼N$ 的随机排列，要求一次只能交换相邻两个数，那么最少需要交换多少次才可以使数列按照从小到大排列呢？

请你求出一个待排序序列的最少交换次数和对应的逆序数列。

> 逆序数列：给定 $n$ 个数 $1,2,…,n$ 的一个排列 $a_1,a_2,…,a_n$，令 $b_i$ 是数 $i$ 在此排列中的逆序数，换句话说，$b_i$ 等于该排列中先于 $i$ 又大于 $i$ 的那些数的个数。数列 $b_1,b_2…b_n$ 称为排列 $a_1,a_2,…,a_n$ 的逆序数列(inversion sequence)。

#### 输入格式

第一行一个整数 $N$。

第二行一个 $1∼N$ 的排列。

#### 输出格式

第一行输出逆序数列，数之间用空格隔开。

第二行输出最少交换次数。

#### 数据范围

$1≤N≤1000$

#### 输入样例：

```
8
4 8 2 7 5 6 1 3
```

#### 输出样例：

```
6 2 5 0 2 2 1 0
18
```

#### 思路

原序列中存在 n 个逆序对,每交换一次最多可以消去一个逆序对,又因为如果整个序列不是升序,则必然有相邻两个数构成逆序对,将其交换就可以减少一个逆序对,故每操作一次必然可以消去一个逆序对,故操作的最少次数就是逆序对的数量.

#### 代码

##### 暴力

```cpp
#include <iostream>

using namespace std;

const int N = 1e3 + 10;

int n, ans;
int q[N], w[N];

int main(void){

    cin >> n;

    for(int i = 0; i < n; i++) cin >> q[i];

    for(int i = 0; i < n; i++){
        for(int j = 0; j < i; j++){
            if(q[i] < q[j]){
                w[q[i]]++;
                ans++;
            }
        }
    }

    for(int i = 1; i <= n; i++) cout << w[i] << " ";

    cout << endl << ans << endl;

    return 0;
}
```

##### 归并排序

```cpp
```

##### 树状数组

```cpp
```




*2022-07-13 周三*