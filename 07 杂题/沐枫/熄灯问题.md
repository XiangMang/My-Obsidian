## [题目详情 - 熄灯问题 - 沐枫OJ (mfstem.org)](https://www.mfstem.org/p/764)

#枚举 #位运算 

### Description

有一个由按钮组成的矩阵，其中每行有 6 个按钮，共 5 行。每个按钮的位置上有一盏灯。当按下一个按钮后，该按钮以及周围位置(上边、下边、左边、右边)的灯都会改变一次。即，如果灯原来是点亮的，就会被熄灭；如果灯原来是熄灭的，则会被点亮。在矩阵角上的按钮改变 3 盏灯的状态；在矩阵边上的按钮改变 4 盏灯的状态；其他的按钮改变 5 盏灯的状态。

![[熄灯问题配图_1.png]]

在上图中，左边矩阵中用 $X$ 标记的按钮表示被按下，右边的矩阵表示灯状态的改变。对矩阵中的每盏灯设置一个初始状态。请你按按钮，直至每一盏灯都熄灭。与一盏灯毗邻的多个按钮被按下时，一个操作会抵消另一次操作的结果。在下图中，第 2 行第 3、5 列的按钮都被按下，因此第 2 行、第 4 列的灯的状态就不改变。

![[熄灯问题配图_2.png]]

请你写一个程序，确定需要按下哪些按钮，恰好使得所有的灯都熄灭。根据上面的规则，我们知道：

1）第 2 次按下同一个按钮时，将抵消第1次按下时所产生的结果。因此，每个按钮最多只需要按下一次；

2）各个按钮被按下的顺序对最终的结果没有影响；

3）对第1行中每盏点亮的灯，按下第2行对应的按钮，就可以熄灭第1行的全部灯。

如此重复下去，可以熄灭第 1、2、3、4 行的全部灯。同样，按下第 1、2、3、4、5 列的按钮，可以熄灭前 5 列的灯。

### Format

#### Input

5 行组成，每一行包括 6 个数字（0 或 1）。相邻两个数字之间用单个空格隔开。

0表示灯的初始状态是熄灭的，1 表示灯的初始状态是点亮的。

#### Output

5 行组成，每一行包括 6 个数字（0 或 1）。相邻两个数字之间用单个空格隔开。

0 表示按钮没有按下的，1 表示按下了按钮。

### Samples

#### 输入数据 1

```input1
0 1 1 0 1 0
1 0 0 1 1 1
0 0 1 0 0 1
1 0 0 1 0 1
0 1 1 1 0 0
```

#### 输出数据 1

```output1
1 0 1 0 0 1
1 1 0 1 0 1
0 0 1 0 1 1
1 0 0 1 0 0
0 1 0 0 0 0
```

### Limitation

1s, 1024KiB for each test case.

## AC code

```cpp
#include <iostream>
#include <cstring>

using namespace std;

int g[5][6], backup[5][6], n[5][6], backup_n[5][6];
// g记录矩阵,n作为答案
int dx[] = {-1, 1, 0, 0, 0}, dy[] = {0, 0, -1, 1, 0};
// 偏移量

void print(void){// 打印
    for(int i = 0; i < 5; i++){
        for(int j = 0; j < 6; j++) printf("%d ", n[i][j]);
        printf("\n");
    }
}

void turn(int x, int y){// 实现按下这一操作
    for(int i = 0; i < 5; i++){
        int a = x + dx[i], b = y + dy[i];
        if(a < 0 || a >= 5 || b < 0 || b >= 6) continue;
        g[a][b] ^= 1;
    }
}

int main(void){

    for(int i = 0; i < 5; i++){
        for(int j = 0; j < 6; j++) scanf("%d", &g[i][j]);
    }

    for(int op = 0; op < 64; op++){// 枚举64种情况
        memcpy(backup, g, sizeof g);
        memcpy(backup_n, n, sizeof g);
        // 将g与n复制一份,在本体上操作
        for(int i = 0; i < 6; i++){// 先在第一行操作
            if(op >> i & 1){
                turn(0, i);
                n[0][i] = 1;
            }
        }
        for(int i = 0; i < 4; i++){// 依次检查前四行
            for(int j = 0; j < 6; j++){
                if(g[i][j] == 1){
                    turn(i + 1, j);
                    n[i + 1][j] = 1;
                }
            }
        }
        bool dark = false;
        for(int i = 0; i < 6; i++){// 检验最后一行的情况
            if(g[4][i] == 1){
                dark = true;
                break;
            }
        }
        if(dark == false){
            print();
            return 0;
        }

        memcpy(g, backup, sizeof g);
        memcpy(n, backup_n, sizeof g);
        // 将备份复制到本体
    }
}
```


相关题目:
1. [[04 95. 费解的开关]]

*2022-09-24 周六*