### [4261. 孤独的照片 - AcWing题库](https://www.acwing.com/problem/content/description/4264/)

#模拟

Farmer John 最近购入了 $N$ 头新的奶牛，每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。

奶牛目前排成一排，Farmer John 想要为每个连续不少于三头奶牛的序列拍摄一张照片。

然而，他不想拍摄这样的照片，其中只有一头牛的品种是更赛牛，或者只有一头牛的品种是荷斯坦牛——他认为这头奇特的牛会感到孤立和不自然。

在为每个连续不少于三头奶牛的序列拍摄了一张照片后，他把所有「孤独的」照片，即其中只有一头更赛牛或荷斯坦奶牛的照片，都扔掉了。

给定奶牛的排列方式，请帮助 Farmer John 求出他会扔掉多少张孤独的照片。

如果两张照片以不同位置的奶牛开始或结束，则认为它们是不同的。

#### 输入格式

输入的第一行包含 $N$。

输入的第二行包含一个长为 $N$ 的字符串。如果队伍中的第 $i$ 头奶牛是更赛牛，则字符串的第 $i$ 个字符为 `G`。否则，第 $i$ 头奶牛是荷斯坦牛，该字符为 `H`。

#### 输出格式

输出 Farmer John 会扔掉的孤独的照片数量。

#### 数据范围

$3 \leq N \leq 5 \times 10^5$

#### 输入样例：

```
5
GHGHG
```

#### 输出样例：

```
3
```

#### 样例解释

这个例子中的每一个长为 $3$ 的子串均恰好包含一头更赛牛或荷斯坦牛——所以这些子串表示孤独的照片，并会被 Farmer John 扔掉。

所有更长的子串（`GHGH`、`HGHG` 和 `GHGHG`）都可以被接受。

#### 思路

##### 思路一

以`G`为例: 枚举包含`G`, 且只包含一个`G`, 且长度大于$3$的字串的数量. 设`G`的左侧有 $L$ 个字母, 右侧有 $R$ 个字母.

1. 计算每个`G`左侧有几个`H`, 右侧有几个`H`. 其方案数为: $l \times r$
2. `G`的左侧没有`H`, 则右侧至少有$2$个`H`. 其方案数为: $r - 1~~(2 \leq r \leq  R)$
3. `G`的右侧没有`H`, 则左侧至少有$2$个`H`. 其方案数为: $l - 1~~(2 \leq l \leq  L)$

##### 思路二

题目要求在一组中只能出现一个`G`或者是一个`H`,我们这边以出现一个`H`为例，(`G`同理)

- 首先第一步记录所有`H`的下标，为了满足题目条件所选区间中一定不会包含两个及以上`H`,所以每次可选的最大区间可以确定
- 接着计算当前位置左边最多能选多少个，以及右边能选多少个，分别用`l`和`r`表示，对于当前H可选的方案可以分为三种
  1. 只在`H`的左半边
     - 当$l<2$时方案为零
     - 当$l>=2$时方案为 $l−1$
  2. 只在`H`的右半边
     - 当$r<2$时方案为零
     - 当$r>=2$时方案为 $r−1$
  3. 在`H`两边
     - 左边选一个对应右边有`r`种选法，左边选两个对应右边也有`r`种选法
     - 故左右两边都有`G`的方案数为: $l \times r$

#### 代码

##### 代码一

```cpp
#include <iostream>

using namespace std;

const int N = 1e6 + 10;

typedef long long LL;

int n;
char str[N];
int l[N], r[N];
// l(r)表示每个字母的左(右)侧有多少个字母与当前字母不一样

int main(){

    cin >> n >> str;

    for(int i = 0, h = 0, g = 0; i < n; i++){// 处理l[i]
        if(str[i] == 'G') l[i] = h, h = 0, g++;
        else l[i] = g, g = 0, h++;
    }

    for(int i = n - 1, h = 0, g = 0; i >= 0; i--){// 处理r[i]
        if(str[i] == 'G') r[i]= h, h = 0, g++;
        else r[i] = g, g = 0, h++;
    }

    LL ans = 0;
    for(int i = 0; i < n; i++){// 计算答案, 注意负数
        ans += (LL)l[i] * r[i] + max(l[i] - 1, 0) + max(r[i] - 1, 0); 
    }

    cout << ans << endl;

    return 0;
}
```

##### 代码二

```cpp
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e6 + 10;

int n, cnt;
char a[N];
int b[N];
LL ans;

int main(){

    cin >> n >> a + 1;

    b[++cnt] = 1;
    // 从1开始计数
    // 初始化第一个字母出现过一次
    for(int i = 2; i <= n; i++){// 记录连续出现字母的个数
        if(a[i] == a[i - 1]) b[cnt]++;
        else b[++cnt] = 1;
    }

    for(int i = 1; i <= cnt; i++){// 
        if(b[i] == 1) ans += (LL)b[i - 1] * b[i + 1];
        // 首先判断孤独的奶牛在中间的情况
        if(b[i - 1] >= 2) ans += b[i - 1] - 1;
        // 然后判断孤独的奶牛在最右侧的情况
        if(b[i + 1] >= 2) ans += b[i + 1] - 1;
        // 最后判断孤独的奶牛在最左侧的情况
    }

    cout << ans << endl;

    return 0;
}
```




*2022-12-28 周三*