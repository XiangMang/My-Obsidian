![[830. 单调栈]]
分析：
本题是单调栈经典且少数的应用。维护栈内元素的单调性是有助于求解左边/右边第一个比它小/大的数这样的问题，与暴力双层 `for` 循环相比能够大量减少比较次数。我们先看一下暴力解的方法：
```cpp
for (int i = 0; i < n; i ++)
    for (int j = i - 1; j >= 0; j --)
        // compare and S_elect
```

很明显这是一个 $O(n^2)$ 的复杂度。在内层的 `for` 循环中，有时会浪费大量时间。比如看下面的分析：

假设输入为 $S_k$，对其分析有两种情况：

1. 若 $S_k＞S_{{k−1}}$，输出 $S_{{k−1}}$即可。
2. 若 $S_k≤S_{k−1}$，要考虑的就多了！
	$A$.  当 $S_k≤S_{k−1}$ 且 $S_k≤[S_{k−1}⋅⋅⋅⋅⋅⋅S_1]$ 时($S_{k−1}⋅⋅⋅⋅⋅⋅S_1$ 大小关系并非具有单调性，可以对其 
	任意一个元素都满足这种小于关系)。对于输入的 $S_k$，要输出 $−1$。
	$B.$  当 $S_k≤S_{k−1}$ 但 $S_k$ 大于 $[S_{k−2}⋅⋅⋅⋅⋅⋅S_1]$ 中的某一个元素时。记为 $S_i$，说明 
	$S_k≤[S_{k−1}⋅⋅⋅⋅⋅⋅S_{i+1}$] 的全部元素，但大于 $S_i$，此时应输出 $S_i$ 。

假设输入为 $S_{k+1}$，对其分析有两种情况：

若 $S_{k+1}＞S_k$，输出 $S_k$ 即可。
若 $S_{k+1}≤S_k$，要考虑的就更多了！
1.  当 $S_{k+1}≤S_k$ 且 $S_{k+1}≤[S_k⋅⋅⋅⋅⋅⋅S_1]$，对于输入的 $S_{k+1}$，要输出 $−1$。
2.  当 $S_{k+1}≤S_k$ 但 $S_{k+1}$ 大于 $[S_{k−1}⋅⋅⋅⋅⋅⋅S_1]$ 中的某一个元素时。记为 $S_j$，说明 $S_k≤[S_k⋅⋅⋅⋅⋅⋅S_j+1]$ 的全部元素，但大于 $S_j$，此时应输出 $S_j$ 。
我们来仔细分析一下输入 $S_{k+1}$ 时 $B$ 的内容：

![[Pasted image 20220729103226.png]]
![[Pasted image 20220729104547.png]]
那么怎么对其优化呢？由上图我们可以得知 $S_{k+1}≤[S_k······S_i+1]$，即 $[S_k······S_i+1]$ 皆不能作为输入值为 $S_{k+1}$ 的输出，而在暴力做法中在这里会消耗大量的比较时间。这就是单调栈改进的地方，在不断出栈的过程中维护一个“合理”的区间。这要求在输入为 $S_k$ 时进行维护，而在输入为 $S_{k+1}$ 时享受这一成果。
具体步骤为：输入为 $S_k$ 时，若栈不为空，将栈中比 $S_k$ 大的元素全部出栈。这一定是有效的，因为：
若 $S_{k+1}$ 大于 $S_k$，输出 $S_k$。
若 $S_{k+1}$ 小于等于 $S_k$，那将更会小于出栈的元素，比了也没用！

文章出处:[AcWing 830. 单调栈 - AcWing](https://www.acwing.com/solution/content/127664/)

*2022-07-29 周五*