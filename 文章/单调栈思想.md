### 引入
何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。

为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。


### 过程
#### 插入

将一个元素插入单调栈时，为了维护栈的单调性，需要在保证将该元素插入到栈顶后整个栈满足单调性的前提下弹出最少的元素。

例如，栈中自顶向下的元素为 $\{0, 11, 45, 81\}$ 。

![[单调栈思想配图_1(白色背景).png]]

插入元素 $14$ 时为了保证单调性需要依次弹出元素 $0, 11$，操作后栈变为 $\{14, 45, 81\}$。

![[单调栈思想配图_2(白色背景).png]]

伪代码描述:
```cpp
insert x
while !sta.empty() && sta.top()<x
    sta.pop()
sta.push(x)

```

### 使用

自然就是从栈顶读出来一个元素，该元素满足单调性的某一端。

例如举例中取出的即栈中的最小值。

![[830. 单调栈]]
分析：
本题是单调栈经典且少数的应用。维护栈内元素的单调性是有助于求解左边/右边第一个比它小/大的数这样的问题，与暴力双层 `for` 循环相比能够大量减少比较次数。我们先看一下暴力解的方法：
```cpp
for (int i = 0; i < n; i ++)
    for (int j = i - 1; j >= 0; j --)
        // compare and S_elect
```

很明显这是一个 $O(n^2)$ 的复杂度。在内层的 `for` 循环中，有时会浪费大量时间。比如看下面的分析：

假设输入为 $S_k$，对其分析有两种情况：

1. 若 $S_k＞S_{{k−1}}$，输出 $S_{{k−1}}$即可。
2. 若 $S_k≤S_{k−1}$，要考虑的就多了！
	$A$.  当 $S_k≤S_{k−1}$ 且 $S_k≤[S_{k−1}⋅⋅⋅⋅⋅⋅S_1]$ 时($S_{k−1}⋅⋅⋅⋅⋅⋅S_1$ 大小关系并非具有单调性，可以对其 
	任意一个元素都满足这种小于关系)。对于输入的 $S_k$，要输出 $−1$。
	$B.$  当 $S_k≤S_{k−1}$ 但 $S_k$ 大于 $[S_{k−2}⋅⋅⋅⋅⋅⋅S_1]$ 中的某一个元素时。记为 $S_i$，说明 
	$S_k≤[S_{k−1}⋅⋅⋅⋅⋅⋅S_{i+1}$] 的全部元素，但大于 $S_i$，此时应输出 $S_i$ 。

假设输入为 $S_{k+1}$，对其分析有两种情况：

若 $S_{k+1}＞S_k$，输出 $S_k$ 即可。
若 $S_{k+1}≤S_k$，要考虑的就更多了！
1.  当 $S_{k+1}≤S_k$ 且 $S_{k+1}≤[S_k⋅⋅⋅⋅⋅⋅S_1]$，对于输入的 $S_{k+1}$，要输出 $−1$。
2.  当 $S_{k+1}≤S_k$ 但 $S_{k+1}$ 大于 $[S_{k−1}⋅⋅⋅⋅⋅⋅S_1]$ 中的某一个元素时。记为 $S_j$，说明 $S_k≤[S_k⋅⋅⋅⋅⋅⋅S_j+1]$ 的全部元素，但大于 $S_j$，此时应输出 $S_j$ 。
我们来仔细分析一下输入 $S_{k+1}$ 时 $B$ 的内容：

![[单调栈思想配图_1.png]]
![[单调栈思想配图_2.png]]
那么怎么对其优化呢？由上图我们可以得知 $S_{k+1}≤[S_k······S_i+1]$，即 $[S_k······S_i+1]$ 皆不能作为输入值为 $S_{k+1}$ 的输出，而在暴力做法中在这里会消耗大量的比较时间。这就是单调栈改进的地方，在不断出栈的过程中维护一个“合理”的区间。这要求在输入为 $S_k$ 时进行维护，而在输入为 $S_{k+1}$ 时享受这一成果。
具体步骤为：输入为 $S_k$ 时，若栈不为空，将栈中比 $S_k$ 大的元素全部出栈。这一定是有效的，因为：
若 $S_{k+1}$ 大于 $S_k$，输出 $S_k$。
若 $S_{k+1}$ 小于等于 $S_k$，那将更会小于出栈的元素，比了也没用！

文章出处:[AcWing 830. 单调栈 - AcWing](https://www.acwing.com/solution/content/127664/)

*2022-07-29 周五*